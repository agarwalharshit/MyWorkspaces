package com.ctci;

import java.util.HashMap;

public class DynamicProgramming {
	int[] arr;
	public static void main(String[] args) {
	// For Question 1
		DynamicProgramming dp = new DynamicProgramming();
		

//		StringBuilder sb= new StringBuilder();
//		sb.append("Hello");
//		sb.append("World");
//		System.out.println(sb);
		
		String s1="He is a very very   good boy, isn't he?";
		s1=s1.replace("!", " ");
		s1=s1.replace(",", " ");
		s1=s1.replace("?", " ");
		s1=s1.replace(".", " ");
		s1=s1.replace("_", " ");
		s1=s1.replace("'", " ");
		s1=s1.replace("@", " ");
		//s1=s1.replace("  ", " ");
		s1=s1.trim();
		int i=0;
		while (i<s1.length()-2){
			if(s1.charAt(i)==' ' && s1.charAt(i+1)==' '){
				s1=s1.substring(0, i)+s1.substring(i+1);
			}else{
				i++;
			}
			
		}
		String[] Str=s1.split(" ");
		System.out.println(Str.length);
		for(String s:Str){
			System.out.println(s);
		}
		
	}
	
	
	int findPathsOfRestrictedSquare(int[][] arr, int row, int column){
		if(!isPathCorrect(arr, row, column)){
			return 0;
		}if((row+1==arr.length-1 && column==arr[1].length-1)||(row==arr.length-1 && column+1==arr[1].length-1)){
		return 1;	
		}
		if(arr[row][column]>-1){
			return arr[row][column];
		}
		
		arr[row][column]=findPathsOfRestrictedSquare(arr, row+1,column)+findPathsOfRestrictedSquare(arr, row,column+1);
		return arr[row][column];
			
	}
	boolean isPathCorrect(int[][] arr, int row, int column){
		if(row>=arr.length || column>=arr[1].length || arr[row][column]==-2){
			return false;
		}else{
			return true;
		}
	}
	
	int Q1TripleStepsSecondApproach(int count, int steps){

		if(count>steps){
			return 0;
		}else if(steps==count){
			return 1;
		}else if(arr[count]>0){
			return 1+arr[count];
		}
		int x= Q1TripleStepsSecondApproach(count+1,steps)+Q1TripleStepsSecondApproach(count+2,steps)+Q1TripleStepsSecondApproach(count+3,steps);
		arr[count]=x;
		if(count==0){
			return arr[0];
		}else{
			return Q1TripleStepsSecondApproach(count-1,steps);
		}
		
		
	}
	
	int craken(int r, int c,HashMap<String,Integer> hm){
		if(r<1 || c<1){
			return 0;
		}
		if(r==1 && c==1){
			return 1;
		}
		int noOfPaths=0;
		String left=r+""+(c-1);
		String top=(r-1)+""+c;
		String diagonal=(r-1)+""+(c-1);
		if(hm.containsKey(left)){
			noOfPaths=noOfPaths+hm.get(left);
		}else{
			noOfPaths=noOfPaths+craken(r,c-1,hm);
		}
		
		if(hm.containsKey(top)){
			noOfPaths=noOfPaths+hm.get(top);
		}else{
			noOfPaths=noOfPaths+craken(r-1,c,hm);
		}
		if(hm.containsKey(diagonal)){
			noOfPaths=noOfPaths+hm.get(diagonal);
		}else{
			noOfPaths=noOfPaths+craken(r-1,c-1,hm);
		}
		return noOfPaths;
		
	}
		
//		System.out.println("R="+r+" C="+c);
//		if(r==(arr.length-1) && c==(arr[0].length)-1){
//			return true;
//		}else{
//			if(r<((arr.length)-1) && !paths.containsKey(((r+1)+""+c)) && arr[r+1][c]>-1){
//				String key=r+1+""+c;
//				String value=paths.get(r+""+c)+","+key;
//				System.out.println("Key="+key+" Value="+value);
//				paths.put(key, value);
//				boolean res=robotMoveQ2(arr, r+1, c, paths);
//				if(res){
//					return true;
//				}
//			}
//
//			if(c<((arr[0].length)-1) && !paths.containsKey((r+""+(c+1)))&& arr[r][c+1]>-1){
//				String key=r+""+(c+1);
//				String value=paths.get(r+""+c)+","+key;
//				System.out.println("Key="+key+" Value="+value);
//				paths.put(key, value);
//				boolean res=robotMoveQ2(arr, r, c+1, paths);
//				if(res){
//					return true;
//				}
//			}
//		}
//		return false;
	//}
	
	
	
	boolean robotMoveQ2(int[][] arr, int r, int c, HashMap paths){
		System.out.println("R="+r+" C="+c);
		if(r==(arr.length-1) && c==(arr[0].length)-1){
			return true;
		}else{
			if(r<((arr.length)-1) && !paths.containsKey(((r+1)+""+c)) && arr[r+1][c]>-1){
				String key=r+1+""+c;
				String value=paths.get(r+""+c)+","+key;
				System.out.println("Key="+key+" Value="+value);
				paths.put(key, value);
				boolean res=robotMoveQ2(arr, r+1, c, paths);
				if(res){
					return true;
				}
			}

			if(c<((arr[0].length)-1) && !paths.containsKey((r+""+(c+1)))&& arr[r][c+1]>-1){
				String key=r+""+(c+1);
				String value=paths.get(r+""+c)+","+key;
				System.out.println("Key="+key+" Value="+value);
				paths.put(key, value);
				boolean res=robotMoveQ2(arr, r, c+1, paths);
				if(res){
					return true;
				}
			}
		}
		return false;
	}
	
	
	
	int tripleStepsQ81(int n, int[] a){

		if(n==0){
			a[n]=0;
			return 1;
		}
		
		if(a[n]==0){
			if(n==1){
				a[n]= tripleStepsQ81(n-1, a);
			}else if(n==2){
				a[n]=tripleStepsQ81(n-1,a)+tripleStepsQ81(n-2,a);
			}else{
			a[n]= tripleStepsQ81(n-1, a)+tripleStepsQ81(n-2,a)+tripleStepsQ81(n-3,a);
			}
		}
		return a[n];
		
		
		
	}
	

}
